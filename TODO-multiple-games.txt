MULTIPLE GAMES SUPPORT - TODO LIST
====================================
TDD approach: Write tests FIRST, watch them fail, THEN implement.


========================================
PHASE 1: UPDATE THE DATA MODEL
========================================
The GameState type needs an ID field so every game knows who it is.

[X] 1a. WRITE TEST: createGame() returns a state that includes an `id` field
        - The id should be a string
        - The id should look like a UUID (not empty, has the right length/format)
        - Everything else (board, currentPlayer, winner, isDraw) should still work
        File: src/tic-tac-toe.test.ts (add to existing tests)

[X] 1b. RUN TEST — confirm it FAILS (because id doesn't exist yet)

[X] 1c. IMPLEMENT: Add `id` to the GameState type
        - Add `id: string` to the GameState type definition
        - Update createGame() to generate a UUID using crypto.randomUUID()
        - Import crypto at the top of the file (Node built-in)
        File: src/tic-tac-toe.ts

[X] 1d. RUN TEST — confirm it PASSES

[X] 1e. RUN ALL EXISTING TESTS — make sure nothing else broke
        (The old tests don't check for id, so they should still pass)


========================================
PHASE 2: UPDATE SERVER STORAGE
========================================
The server currently holds one game in a plain variable.
Change it to a Map that holds many games, keyed by their ID.

This is an internal change — no new API endpoints yet, just changing
how the server stores data.

[ ] 2a. In server.ts, replace:
            let gameState = createGame()
        with:
            A new Map (empty to start — games get created via the API)
        File: src/server.ts

        NOTE: The old endpoints will break at this point. That's expected.
              We're about to rewrite them anyway.


========================================
PHASE 3: API TESTS (WRITE ALL TESTS FIRST)
========================================
Write tests for the NEW endpoints before implementing them.
File: src/api.test.ts

You'll need a way to make HTTP requests in tests. Common choice:
supertest (lets you test Express apps without starting a real server).
You may need to install it first.

Also: the Express app (the `app` variable) needs to be exported from
server.ts so the test file can import it.

--- CREATE A NEW GAME ---

[X] 3a. WRITE TEST: POST /api/games creates a new game
        - Response status should be 200 (or 201)
        - Response body should have an `id` field (string, UUID)
        - Response body should have a fresh game state
          (empty board, currentPlayer is "X", no winner, not a draw)

[X] 3b. WRITE TEST: POST /api/games twice creates TWO DIFFERENT games
        - Call POST /api/games twice
        - The two responses should have DIFFERENT ids
        - Both should be fresh game states

--- LIST ALL GAMES ---

[X] 3c. WRITE TEST: GET /api/games returns empty list when no games exist
        - Response should be an empty array (or empty object — decide which)

[X] 3d. WRITE TEST: GET /api/games returns all games after creating some
        - Create 2-3 games via POST /api/games
        - GET /api/games should return all of them
        - Each game in the list should have its id and state

--- GET ONE SPECIFIC GAME ---

[X] 3e. WRITE TEST: GET /api/games/:id returns the correct game
        - Create a game, note its id
        - GET /api/games/<that-id> should return that specific game

[X] 3f. WRITE TEST: GET /api/games/:id returns 404 for non-existent id
        - GET /api/games/not-a-real-id should return status 404
        - Response should have an error message

--- MAKE A MOVE IN A SPECIFIC GAME ---

[X] 3g. WRITE TEST: POST /api/games/:id/move makes a move in the right game
        - Create a game, note its id
        - POST /api/games/<id>/move with { position: 0 }
        - Response should show the move was made (board[0] is "X")
        - currentPlayer should have switched

[X] 3h. WRITE TEST: POST /api/games/:id/move returns 404 for non-existent id
        - POST /api/games/fake-id/move with { position: 0 }
        - Should return 404

[X] 3i. WRITE TEST: making a move in one game doesn't affect another
        - Create two games (game A and game B)
        - Make a move in game A
        - GET game B — it should still be a fresh, empty game

--- EDGE CASES ---

[X] 3j. WRITE TEST: invalid move returns an error (not a crash)
        - Create a game
        - POST /api/games/<id>/move with { position: 99 }
        - Should return a 400 (bad request) with an error message
        - Server should NOT crash

[ ] 3k. WRITE TEST: move on an occupied cell returns an error
        - Create a game
        - Make a move at position 0
        - Try to make another move at position 0
        - Should return 400 with an error message

[X] 3l. RUN ALL API TESTS — confirm they all FAIL
        (None of the endpoints exist yet, so they should all fail)


========================================
PHASE 4: IMPLEMENT THE API ENDPOINTS
========================================
Now make the tests pass, one endpoint at a time.
File: src/server.ts

[ ] 4a. Export the Express app so tests can import it
        (The ViteExpress.listen part should only run when NOT in test mode)

[ ] 4b. IMPLEMENT: POST /api/games — create a new game
        - Call createGame() to get a new game state (which now has an id)
        - Store it in the Map using its id as the key
        - Return the game state

[ ] 4c. RUN TESTS 3a, 3b — check if they pass now

[ ] 4d. IMPLEMENT: GET /api/games — list all games
        - Read all entries from the Map
        - Return them as a list
        - If Map is empty, return empty list

[ ] 4e. RUN TEST 3c, 3d — check if they pass now

[ ] 4f. IMPLEMENT: GET /api/games/:id — get one specific game
        - Read the :id from the URL
        - Look it up in the Map
        - If found: return it
        - If NOT found: return 404 with error message

[ ] 4g. RUN TESTS 3e, 3f — check if they pass now

[ ] 4h. IMPLEMENT: POST /api/games/:id/move — make a move
        - Read the :id from the URL
        - Look up the game in the Map
        - If NOT found: return 404
        - Read position from request body
        - Try to call makeMove() on that game
        - If makeMove throws (invalid move): return 400 with the error message
        - If success: update the Map with the new state, return it

[ ] 4i. RUN TESTS 3g, 3h, 3i, 3j, 3k — check if they pass now

[ ] 4j. RUN ALL TESTS (game logic + API) — everything should be green


========================================
PHASE 5: CLEAN UP OLD ENDPOINTS
========================================

[ ] 5a. Remove the old endpoints that no longer apply:
        - DELETE: POST /api/reset  (replaced by POST /api/games)
        - DELETE: POST /api/move   (replaced by POST /api/games/:id/move)
        - DELETE: GET  /api/game   (replaced by GET  /api/games/:id)

[ ] 5b. Remove the old `let gameState = createGame()` line if it's still there

[ ] 5c. RUN ALL TESTS — make sure nothing broke


========================================
PHASE 6: UPDATE THE UI (afternoon)
========================================
The React app currently talks to the old endpoints and shows one game.
It needs to:

[X] 6a. On load: fetch the list of games (GET /api/games)

[ ] 6b. Show a game list / lobby screen where you can:
        - See all existing games (with their IDs, maybe their status)
        - Click one to open it
        - Click "New Game" to create one (POST /api/games)

[ ] 6c. When a game is selected: fetch it (GET /api/games/:id) and show the board

[ ] 6d. Update handleCellClick to hit POST /api/games/:id/move
        (instead of the old POST /api/move)

[ ] 6e. Update handleNewGame to hit POST /api/games
        (instead of the old POST /api/reset)

[ ] 6f. Add a way to go back to the game list from inside a game

[ ] 6g. Keep track of which game is currently selected
        (the app needs to know: "am I showing the list, or a specific game?")


========================================
QUICK REFERENCE: OLD API vs NEW API
========================================

OLD                         NEW
---                         ---
GET  /api/game          ->  GET  /api/games/:id
POST /api/move          ->  POST /api/games/:id/move
POST /api/reset         ->  POST /api/games
(nothing)               ->  GET  /api/games


========================================
ORDER OF OPERATIONS
========================================

Morning (server work, TDD):
  Phase 1 -> Phase 2 -> Phase 3 -> Phase 4 -> Phase 5

Afternoon (UI work):
  Phase 6
